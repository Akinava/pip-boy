
SmileyFlashTest.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000266  00007800  00007800  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000082  00800100  00800100  000002da  2**0
                  ALLOC
  2 .debug_aranges 00000020  00000000  00000000  000002da  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 00000064  00000000  00000000  000002fa  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   000003a6  00000000  00000000  0000035e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 000001e3  00000000  00000000  00000704  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   00000262  00000000  00000000  000008e7  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00000040  00000000  00000000  00000b4c  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    00000177  00000000  00000000  00000b8c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00000074  00000000  00000000  00000d03  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000070  00000000  00000000  00000d77  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007800 <__vectors>:
    7800:	0c 94 57 3c 	jmp	0x78ae	; 0x78ae <__ctors_end>
    7804:	0c 94 69 3c 	jmp	0x78d2	; 0x78d2 <__bad_interrupt>
    7808:	0c 94 69 3c 	jmp	0x78d2	; 0x78d2 <__bad_interrupt>
    780c:	0c 94 69 3c 	jmp	0x78d2	; 0x78d2 <__bad_interrupt>
    7810:	0c 94 69 3c 	jmp	0x78d2	; 0x78d2 <__bad_interrupt>
    7814:	0c 94 69 3c 	jmp	0x78d2	; 0x78d2 <__bad_interrupt>
    7818:	0c 94 69 3c 	jmp	0x78d2	; 0x78d2 <__bad_interrupt>
    781c:	0c 94 69 3c 	jmp	0x78d2	; 0x78d2 <__bad_interrupt>
    7820:	0c 94 69 3c 	jmp	0x78d2	; 0x78d2 <__bad_interrupt>
    7824:	0c 94 69 3c 	jmp	0x78d2	; 0x78d2 <__bad_interrupt>
    7828:	0c 94 69 3c 	jmp	0x78d2	; 0x78d2 <__bad_interrupt>
    782c:	0c 94 69 3c 	jmp	0x78d2	; 0x78d2 <__bad_interrupt>
    7830:	0c 94 69 3c 	jmp	0x78d2	; 0x78d2 <__bad_interrupt>
    7834:	0c 94 69 3c 	jmp	0x78d2	; 0x78d2 <__bad_interrupt>
    7838:	0c 94 69 3c 	jmp	0x78d2	; 0x78d2 <__bad_interrupt>
    783c:	0c 94 69 3c 	jmp	0x78d2	; 0x78d2 <__bad_interrupt>
    7840:	0c 94 69 3c 	jmp	0x78d2	; 0x78d2 <__bad_interrupt>
    7844:	0c 94 69 3c 	jmp	0x78d2	; 0x78d2 <__bad_interrupt>
    7848:	0c 94 69 3c 	jmp	0x78d2	; 0x78d2 <__bad_interrupt>
    784c:	0c 94 69 3c 	jmp	0x78d2	; 0x78d2 <__bad_interrupt>
    7850:	0c 94 69 3c 	jmp	0x78d2	; 0x78d2 <__bad_interrupt>
    7854:	0c 94 69 3c 	jmp	0x78d2	; 0x78d2 <__bad_interrupt>
    7858:	0c 94 69 3c 	jmp	0x78d2	; 0x78d2 <__bad_interrupt>
    785c:	0c 94 69 3c 	jmp	0x78d2	; 0x78d2 <__bad_interrupt>
    7860:	0c 94 69 3c 	jmp	0x78d2	; 0x78d2 <__bad_interrupt>
    7864:	0c 94 69 3c 	jmp	0x78d2	; 0x78d2 <__bad_interrupt>

00007868 <HELLO>:
    7868:	53 6d 69 6c 65 79 46 6c 61 73 68 54 65 73 74 20     SmileyFlashTest 
    7878:	2d 20 41 72 64 75 69 6e 6f 20 31 2e 30 31 0a 00     - Arduino 1.01..

00007888 <__c.1423>:
    7888:	54 68 69 73 20 69 73 20 61 20 74 65 73 74 20 66     This is a test f
    7898:	6f 72 20 73 65 6e 64 69 6e 67 20 61 20 73 74 72     or sending a str
    78a8:	69 6e 67 2e 0a 00                                   ing...

000078ae <__ctors_end>:
    78ae:	11 24       	eor	r1, r1
    78b0:	1f be       	out	0x3f, r1	; 63
    78b2:	cf ef       	ldi	r28, 0xFF	; 255
    78b4:	d8 e0       	ldi	r29, 0x08	; 8
    78b6:	de bf       	out	0x3e, r29	; 62
    78b8:	cd bf       	out	0x3d, r28	; 61

000078ba <__do_clear_bss>:
    78ba:	11 e0       	ldi	r17, 0x01	; 1
    78bc:	a0 e0       	ldi	r26, 0x00	; 0
    78be:	b1 e0       	ldi	r27, 0x01	; 1
    78c0:	01 c0       	rjmp	.+2      	; 0x78c4 <.do_clear_bss_start>

000078c2 <.do_clear_bss_loop>:
    78c2:	1d 92       	st	X+, r1

000078c4 <.do_clear_bss_start>:
    78c4:	a2 38       	cpi	r26, 0x82	; 130
    78c6:	b1 07       	cpc	r27, r17
    78c8:	e1 f7       	brne	.-8      	; 0x78c2 <.do_clear_bss_loop>
    78ca:	0e 94 88 3c 	call	0x7910	; 0x7910 <main>
    78ce:	0c 94 31 3d 	jmp	0x7a62	; 0x7a62 <_exit>

000078d2 <__bad_interrupt>:
    78d2:	0c 94 00 3c 	jmp	0x7800	; 0x7800 <__vectors>

000078d6 <isByteAvailable>:

uint8_t isByteAvailable()
{
	// Does the RX0 bit of the USART Status and Control Register
	// indicate a char has been received?
	if ( (USART_CONTROL_STATUS_REG_A & (0x80)) ) return 1;
    78d6:	80 91 c0 00 	lds	r24, 0x00C0
	return 0;
}
    78da:	88 1f       	adc	r24, r24
    78dc:	88 27       	eor	r24, r24
    78de:	88 1f       	adc	r24, r24
    78e0:	08 95       	ret

000078e2 <sendStringP>:
	// Put data into buffer, sends the data
	USART_DATA_REG = data;
}

void sendStringP(const char *FlashString)
{
    78e2:	bc 01       	movw	r22, r24
    78e4:	20 e0       	ldi	r18, 0x00	; 0
    78e6:	30 e0       	ldi	r19, 0x00	; 0
    78e8:	09 c0       	rjmp	.+18     	; 0x78fc <sendStringP+0x1a>
	return USART_DATA_REG;
}

void sendByte( uint8_t data )
{
	wdt_reset(); // reset the watchdog timer, if it is set
    78ea:	a8 95       	wdr
	// Wait for empty transmit buffer 
	while ( !( USART_CONTROL_STATUS_REG_A & (1<<USART_READY_TO_TRANSMIT)) );
    78ec:	80 91 c0 00 	lds	r24, 0x00C0
    78f0:	85 ff       	sbrs	r24, 5
    78f2:	fc cf       	rjmp	.-8      	; 0x78ec <sendStringP+0xa>
	// Put data into buffer, sends the data
	USART_DATA_REG = data;
    78f4:	40 93 c6 00 	sts	0x00C6, r20

	// The 'for' logic terminates if the byte is '\0' or if i = 80.
	// '\0' is 'null' and terminates C strings
	// The 80 prevents too much overrun if we get a bad pointer
	// and it limits the string size	
	for( i = 0 ; pgm_read_byte(&FlashString[i]) && i < 80; i++) 
    78f8:	2f 5f       	subi	r18, 0xFF	; 255
    78fa:	3f 4f       	sbci	r19, 0xFF	; 255
    78fc:	fb 01       	movw	r30, r22
    78fe:	e2 0f       	add	r30, r18
    7900:	f3 1f       	adc	r31, r19
    7902:	44 91       	lpm	r20, Z+
    7904:	44 23       	and	r20, r20
    7906:	19 f0       	breq	.+6      	; 0x790e <sendStringP+0x2c>
    7908:	20 35       	cpi	r18, 0x50	; 80
    790a:	31 05       	cpc	r19, r1
    790c:	71 f7       	brne	.-36     	; 0x78ea <sendStringP+0x8>
    790e:	08 95       	ret

00007910 <main>:
// kilometer radius. So don't even consider using it for any reason whatsoever!

#include "SmileyFlashTest.h"

int main(void) 
{ 
    7910:	df 92       	push	r13
    7912:	ef 92       	push	r14
    7914:	ff 92       	push	r15
    7916:	0f 93       	push	r16
    7918:	1f 93       	push	r17
    791a:	cf 93       	push	r28
    791c:	df 93       	push	r29
	USART Functions
******************************************************/
void USARTInit()
{
	// Set Baud registers
	USART_BAUD_RATE_HIGH = (F_CPU/(BAUD*16L)-1) >> 8;
    791e:	10 92 c5 00 	sts	0x00C5, r1
	USART_BAUD_RATE_LOW = (uint8_t)(F_CPU/(BAUD*16L)-1);
    7922:	80 e1       	ldi	r24, 0x10	; 16
    7924:	80 93 c4 00 	sts	0x00C4, r24

	// Enable receiver and transmitter
	USART_CONTROL_STATUS_REG_B = (1 << USART_ENABLE_RECEIVER) | (1 << USART_ENABLE_TRANSMITTER);
    7928:	88 e1       	ldi	r24, 0x18	; 24
    792a:	80 93 c1 00 	sts	0x00C1, r24
	// Set frame format: n,8,1
#if defined(BeAVR40) || defined(Arduino)
	USART_CONTROL_STATUS_REG_C |= (1 << USART_STOP_BIT_SELECT) | (1 << USART_CHARACTER_SIZE);  
    792e:	80 91 c2 00 	lds	r24, 0x00C2
    7932:	8a 60       	ori	r24, 0x0A	; 10
    7934:	80 93 c2 00 	sts	0x00C2, r24
	uint8_t size = 16;

	Initialization();

	// Send the hello string selected by the #define
	sendStringP(HELLO);
    7938:	88 e6       	ldi	r24, 0x68	; 104
    793a:	98 e7       	ldi	r25, 0x78	; 120
    793c:	0e 94 71 3c 	call	0x78e2	; 0x78e2 <sendStringP>
	// Send a test string
	sendStringP(PSTR("This is a test for sending a string.\n"));
    7940:	88 e8       	ldi	r24, 0x88	; 136
    7942:	98 e7       	ldi	r25, 0x78	; 120
    7944:	0e 94 71 3c 	call	0x78e2	; 0x78e2 <sendStringP>
{
	wdt_reset(); // reset the watchdog timer, if it is set
	// Wait for empty transmit buffer 
	while ( !( USART_CONTROL_STATUS_REG_A & (1<<USART_READY_TO_TRANSMIT)) );
	// Put data into buffer, sends the data
	USART_DATA_REG = data;
    7948:	9f e3       	ldi	r25, 0x3F	; 63
    794a:	d9 2e       	mov	r13, r25
	// address is global and set elsewhere
	uint16_t tempAddress = address;	
	uint16_t i,tempWord;

	// Perform page erase
    boot_page_erase(address);
    794c:	83 e0       	ldi	r24, 0x03	; 3
    794e:	e8 2e       	mov	r14, r24
    7950:	60 e0       	ldi	r22, 0x00	; 0
    7952:	70 e2       	ldi	r23, 0x20	; 32

		// load the big end byte
		tempWord += (pageBuffer[i+1] << 8);
		
		// put the word into the page butter
        boot_page_fill(address,tempWord);;
    7954:	ff 24       	eor	r15, r15
    7956:	f3 94       	inc	r15
		// incrememnt the word address						
        address = address + 2;
    } 
    
	// write the page to flash
    boot_page_write(tempAddress);
    7958:	05 e0       	ldi	r16, 0x05	; 5

	// wait until finished writing
    boot_spm_busy_wait();
	
	// Re-enable the RWW section 
    boot_rww_enable();
    795a:	11 e1       	ldi	r17, 0x11	; 17

uint8_t isByteAvailable()
{
	// Does the RX0 bit of the USART Status and Control Register
	// indicate a char has been received?
	if ( (USART_CONTROL_STATUS_REG_A & (0x80)) ) return 1;
    795c:	80 91 c0 00 	lds	r24, 0x00C0
    7960:	87 ff       	sbrs	r24, 7
    7962:	fc cf       	rjmp	.-8      	; 0x795c <main+0x4c>
	return 0;
}

uint8_t receiveByte( void )
{
	return USART_DATA_REG;
    7964:	80 91 c6 00 	lds	r24, 0x00C6
	{
		// receiveByte waits for a byte 
		if(isByteAvailable())
		{
			b = receiveByte();
			if( b == 'r') // Read 16 bytes
    7968:	82 37       	cpi	r24, 0x72	; 114
    796a:	81 f4       	brne	.+32     	; 0x798c <main+0x7c>
    796c:	e0 e0       	ldi	r30, 0x00	; 0
    796e:	f0 e2       	ldi	r31, 0x20	; 32
{ 
	uint8_t data;

	do {
		// read program memory byte at address
		data = pgm_read_byte_near(address++);
    7970:	94 91       	lpm	r25, Z+
	return USART_DATA_REG;
}

void sendByte( uint8_t data )
{
	wdt_reset(); // reset the watchdog timer, if it is set
    7972:	a8 95       	wdr
	// Wait for empty transmit buffer 
	while ( !( USART_CONTROL_STATUS_REG_A & (1<<USART_READY_TO_TRANSMIT)) );
    7974:	80 91 c0 00 	lds	r24, 0x00C0
    7978:	85 ff       	sbrs	r24, 5
    797a:	fc cf       	rjmp	.-8      	; 0x7974 <main+0x64>
	// Put data into buffer, sends the data
	USART_DATA_REG = data;
    797c:	90 93 c6 00 	sts	0x00C6, r25
    7980:	31 96       	adiw	r30, 0x01	; 1
			
		// reduce number of bytes to read by one		   				
		size--;	

		// loop while size is greater than 0						
	} while (size);						
    7982:	80 e2       	ldi	r24, 0x20	; 32
    7984:	e0 31       	cpi	r30, 0x10	; 16
    7986:	f8 07       	cpc	r31, r24
    7988:	99 f7       	brne	.-26     	; 0x7970 <main+0x60>
    798a:	e8 cf       	rjmp	.-48     	; 0x795c <main+0x4c>
			if( b == 'r') // Read 16 bytes
			{
				address = TEST_ADDRESS;
				blockFlashRead(size);
			}
			else if(b == 'w') // Write increasing sequence
    798c:	87 37       	cpi	r24, 0x77	; 119
    798e:	81 f5       	brne	.+96     	; 0x79f0 <main+0xe0>
    7990:	80 e0       	ldi	r24, 0x00	; 0
    7992:	90 e0       	ldi	r25, 0x00	; 0
			{
				// create and store sequence 0 to 0x0F
				for (i=0; i<size; i++) 
				{
					pageBuffer[i]=i;
    7994:	fc 01       	movw	r30, r24
    7996:	ee 5f       	subi	r30, 0xFE	; 254
    7998:	fe 4f       	sbci	r31, 0xFE	; 254
    799a:	80 83       	st	Z, r24
				blockFlashRead(size);
			}
			else if(b == 'w') // Write increasing sequence
			{
				// create and store sequence 0 to 0x0F
				for (i=0; i<size; i++) 
    799c:	01 96       	adiw	r24, 0x01	; 1
    799e:	80 31       	cpi	r24, 0x10	; 16
    79a0:	91 05       	cpc	r25, r1
    79a2:	c1 f7       	brne	.-16     	; 0x7994 <main+0x84>
	// address is global and set elsewhere
	uint16_t tempAddress = address;	
	uint16_t i,tempWord;

	// Perform page erase
    boot_page_erase(address);
    79a4:	fb 01       	movw	r30, r22
    79a6:	e0 92 57 00 	sts	0x0057, r14
    79aa:	e8 95       	spm

	// Wait until the memory is erased
    boot_spm_busy_wait();		
    79ac:	07 b6       	in	r0, 0x37	; 55
    79ae:	00 fc       	sbrc	r0, 0
    79b0:	fd cf       	rjmp	.-6      	; 0x79ac <main+0x9c>
    79b2:	a2 e0       	ldi	r26, 0x02	; 2
    79b4:	b1 e0       	ldi	r27, 0x01	; 1
    79b6:	e0 e0       	ldi	r30, 0x00	; 0
    79b8:	f0 e2       	ldi	r31, 0x20	; 32

	// fill the flash page buffer with the data
    for(i = 0; i < size; i+=2)
	{
		// load the little end byte from the word
		tempWord = pageBuffer[i];
    79ba:	8c 91       	ld	r24, X

		// load the big end byte
		tempWord += (pageBuffer[i+1] << 8);
		
		// put the word into the page butter
        boot_page_fill(address,tempWord);;
    79bc:	11 96       	adiw	r26, 0x01	; 1
    79be:	3c 91       	ld	r19, X
    79c0:	11 97       	sbiw	r26, 0x01	; 1
    79c2:	20 e0       	ldi	r18, 0x00	; 0
    79c4:	e9 01       	movw	r28, r18
    79c6:	c8 0f       	add	r28, r24
    79c8:	d1 1d       	adc	r29, r1
    79ca:	0e 01       	movw	r0, r28
    79cc:	f0 92 57 00 	sts	0x0057, r15
    79d0:	e8 95       	spm
    79d2:	11 24       	eor	r1, r1
    79d4:	32 96       	adiw	r30, 0x02	; 2
    79d6:	12 96       	adiw	r26, 0x02	; 2

	// Wait until the memory is erased
    boot_spm_busy_wait();		

	// fill the flash page buffer with the data
    for(i = 0; i < size; i+=2)
    79d8:	80 e2       	ldi	r24, 0x20	; 32
    79da:	e0 31       	cpi	r30, 0x10	; 16
    79dc:	f8 07       	cpc	r31, r24
    79de:	69 f7       	brne	.-38     	; 0x79ba <main+0xaa>
		// incrememnt the word address						
        address = address + 2;
    } 
    
	// write the page to flash
    boot_page_write(tempAddress);
    79e0:	fb 01       	movw	r30, r22
    79e2:	00 93 57 00 	sts	0x0057, r16
    79e6:	e8 95       	spm

	// wait until finished writing
    boot_spm_busy_wait();
    79e8:	07 b6       	in	r0, 0x37	; 55
    79ea:	00 fc       	sbrc	r0, 0
    79ec:	fd cf       	rjmp	.-6      	; 0x79e8 <main+0xd8>
    79ee:	2d c0       	rjmp	.+90     	; 0x7a4a <main+0x13a>

				address = TEST_ADDRESS;

				blockFlashLoad(size);
			}	
			else if(b == 'W') // Write zeros
    79f0:	87 35       	cpi	r24, 0x57	; 87
    79f2:	79 f5       	brne	.+94     	; 0x7a52 <main+0x142>
    79f4:	a2 e0       	ldi	r26, 0x02	; 2
    79f6:	b1 e0       	ldi	r27, 0x01	; 1
    79f8:	fd 01       	movw	r30, r26
			{
				// create and store zeros
				for (i=0; i<size; i++) 
				{
					pageBuffer[i]=0;
    79fa:	11 92       	st	Z+, r1
				blockFlashLoad(size);
			}	
			else if(b == 'W') // Write zeros
			{
				// create and store zeros
				for (i=0; i<size; i++) 
    79fc:	81 e0       	ldi	r24, 0x01	; 1
    79fe:	e2 31       	cpi	r30, 0x12	; 18
    7a00:	f8 07       	cpc	r31, r24
    7a02:	d9 f7       	brne	.-10     	; 0x79fa <main+0xea>
	// address is global and set elsewhere
	uint16_t tempAddress = address;	
	uint16_t i,tempWord;

	// Perform page erase
    boot_page_erase(address);
    7a04:	fb 01       	movw	r30, r22
    7a06:	e0 92 57 00 	sts	0x0057, r14
    7a0a:	e8 95       	spm

	// Wait until the memory is erased
    boot_spm_busy_wait();		
    7a0c:	07 b6       	in	r0, 0x37	; 55
    7a0e:	00 fc       	sbrc	r0, 0
    7a10:	fd cf       	rjmp	.-6      	; 0x7a0c <main+0xfc>
    7a12:	e0 e0       	ldi	r30, 0x00	; 0
    7a14:	f0 e2       	ldi	r31, 0x20	; 32

	// fill the flash page buffer with the data
    for(i = 0; i < size; i+=2)
	{
		// load the little end byte from the word
		tempWord = pageBuffer[i];
    7a16:	8c 91       	ld	r24, X

		// load the big end byte
		tempWord += (pageBuffer[i+1] << 8);
		
		// put the word into the page butter
        boot_page_fill(address,tempWord);;
    7a18:	11 96       	adiw	r26, 0x01	; 1
    7a1a:	5c 91       	ld	r21, X
    7a1c:	11 97       	sbiw	r26, 0x01	; 1
    7a1e:	40 e0       	ldi	r20, 0x00	; 0
    7a20:	ea 01       	movw	r28, r20
    7a22:	c8 0f       	add	r28, r24
    7a24:	d1 1d       	adc	r29, r1
    7a26:	0e 01       	movw	r0, r28
    7a28:	f0 92 57 00 	sts	0x0057, r15
    7a2c:	e8 95       	spm
    7a2e:	11 24       	eor	r1, r1
    7a30:	32 96       	adiw	r30, 0x02	; 2
    7a32:	12 96       	adiw	r26, 0x02	; 2

	// Wait until the memory is erased
    boot_spm_busy_wait();		

	// fill the flash page buffer with the data
    for(i = 0; i < size; i+=2)
    7a34:	80 e2       	ldi	r24, 0x20	; 32
    7a36:	e0 31       	cpi	r30, 0x10	; 16
    7a38:	f8 07       	cpc	r31, r24
    7a3a:	69 f7       	brne	.-38     	; 0x7a16 <main+0x106>
		// incrememnt the word address						
        address = address + 2;
    } 
    
	// write the page to flash
    boot_page_write(tempAddress);
    7a3c:	fb 01       	movw	r30, r22
    7a3e:	00 93 57 00 	sts	0x0057, r16
    7a42:	e8 95       	spm

	// wait until finished writing
    boot_spm_busy_wait();
    7a44:	07 b6       	in	r0, 0x37	; 55
    7a46:	00 fc       	sbrc	r0, 0
    7a48:	fd cf       	rjmp	.-6      	; 0x7a44 <main+0x134>
	
	// Re-enable the RWW section 
    boot_rww_enable();
    7a4a:	10 93 57 00 	sts	0x0057, r17
    7a4e:	e8 95       	spm
    7a50:	85 cf       	rjmp	.-246    	; 0x795c <main+0x4c>
	return USART_DATA_REG;
}

void sendByte( uint8_t data )
{
	wdt_reset(); // reset the watchdog timer, if it is set
    7a52:	a8 95       	wdr
	// Wait for empty transmit buffer 
	while ( !( USART_CONTROL_STATUS_REG_A & (1<<USART_READY_TO_TRANSMIT)) );
    7a54:	80 91 c0 00 	lds	r24, 0x00C0
    7a58:	85 ff       	sbrs	r24, 5
    7a5a:	fc cf       	rjmp	.-8      	; 0x7a54 <main+0x144>
	// Put data into buffer, sends the data
	USART_DATA_REG = data;
    7a5c:	d0 92 c6 00 	sts	0x00C6, r13
    7a60:	7d cf       	rjmp	.-262    	; 0x795c <main+0x4c>

00007a62 <_exit>:
    7a62:	f8 94       	cli

00007a64 <__stop_program>:
    7a64:	ff cf       	rjmp	.-2      	; 0x7a64 <__stop_program>
